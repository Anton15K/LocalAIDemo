<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" 
      th:replace="~{layout/base :: html(pageTitle='Problem Details', currentPage='problems', content=~{::content})}">
<body>
<div th:fragment="content">
    <!-- Back Button -->
    <div class="mb-6">
        <a href="/problems" class="inline-flex items-center ai-accent hover:opacity-90">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
            </svg>
            Back to Problems
        </a>
    </div>

    <!-- Problem Card -->
    <div class="ai-surface rounded-lg overflow-hidden shadow-sm">
        <!-- Header -->
        <div class="p-6 bg-white border-b ai-border">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-3">
                    <span class="px-3 py-1 bg-blue-50 text-blue-700 border border-blue-100 rounded-full text-sm font-medium" th:text="${problem.topic}">Algebra</span>
                    <span th:if="${problem.subtopic}" class="px-3 py-1 bg-gray-50 text-gray-600 border border-gray-200 rounded-full text-sm" th:text="${problem.subtopic}">Subtopic</span>
                </div>
                <div th:if="${problem.difficulty}" class="flex items-center space-x-1">
                    <span class="text-sm text-gray-500">Difficulty:</span>
                    <span th:each="i : ${#numbers.sequence(1,5)}">
                        <svg th:if="${i <= problem.difficulty}" class="w-5 h-5 text-yellow-400" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
                        </svg>
                        <svg th:unless="${i <= problem.difficulty}" class="w-5 h-5 text-gray-200" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
                        </svg>
                    </span>
                </div>
            </div>
            <div th:if="${problem.sourceId}" class="mt-4 text-gray-500 text-sm">
                Problem ID: <span th:text="${problem.sourceId}">math_001</span>
            </div>
        </div>

        <!-- Problem Statement -->
        <div class="p-6" style="border-bottom: 1px solid var(--border)">
            <h2 class="text-lg font-semibold mb-4" style="color: var(--text-main)">Problem Statement</h2>
            <div class="prose max-w-none">
                <!-- Rendered target with raw content in data attribute -->
                <div id="problem-statement" 
                     class="markdown-content" 
                     style="color: var(--text-main)"
                     th:attr="data-raw=${problem.statement}">
                    <p class="text-sm italic" style="color: var(--text-muted)">Loading statement...</p>
                </div>
            </div>
        </div>

        <!-- Solution Section (Collapsible) -->
        <div class="p-6" x-data="{ showSolution: false }">
            <div class="flex items-center justify-between">
                <h2 class="text-lg font-semibold" style="color: var(--text-main)">Solution</h2>
                <button
                        @click="showSolution = !showSolution; if (showSolution) { $nextTick(() => renderProblemSolution()); }"
                        class="px-4 py-2 text-sm font-medium rounded-md transition shadow-sm border border-gray-200"
                        :class="showSolution ? 'bg-gray-50 text-gray-700 hover:bg-gray-100' : 'bg-blue-600 text-white hover:bg-blue-700'">
                    <span x-show="!showSolution">Show Solution</span>
                    <span x-show="showSolution">Hide Solution</span>
                </button>
            </div>
            <div x-show="showSolution" x-transition class="mt-4">
                <div class="bg-gray-50 rounded-lg p-6 border border-gray-100">
                    <div th:if="${problem.solution}" class="prose max-w-none">
                        <!-- Rendered target with raw content in data attribute -->
                        <div id="problem-solution" 
                             class="markdown-content" 
                             style="color: var(--text-main)"
                             th:attr="data-raw=${problem.solution}">
                            <p class="text-sm italic" style="color: var(--text-muted)">Loading solution...</p>
                        </div>
                    </div>
                    <p th:unless="${problem.solution}" class="italic" style="color: var(--text-muted)">
                        No solution available for this problem.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Note: we intentionally don't render a separate "Answer" field here.
         The backend `Problem` entity currently includes `statement` and optional `solution`, but no `answer` property.
         If we later add an `answer` column + field, we can reintroduce an Answer box. -->

    <!-- Related Problems (if available) -->
    <div th:if="${not #lists.isEmpty(relatedProblems)}" class="mt-8">
        <h2 class="text-xl font-bold mb-4" style="color: var(--text-main)">Related Problems</h2>
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            <a th:each="related : ${relatedProblems}" 
               th:href="@{/problems/{id}(id=${related.id})}"
               class="ai-surface rounded-lg p-4 transition shadow-sm card-hover">
                <span class="px-2 py-1 rounded-full text-xs font-medium" style="background: #F5F3FF; color: var(--accent-violet); border: 1px solid #DDD6FE"
                      th:text="${related.topic}">Topic</span>
                <p class="mt-2 text-sm line-clamp-3" style="color: var(--text-muted)" th:text="${related.statement}">
                    Related problem statement...
                </p>
            </a>
        </div>
    </div>

    <!-- Ensure MathJax typesets even if the page loads before MathJax finishes initializing -->
    <script th:inline="none">
        (function () {
            function normalizeMathDelimiters(text) {
                if (!text) return '';
                return text
                    .replace(/\\\[/g, '$$$$')
                    .replace(/\\\]/g, '$$$$')
                    .replace(/\\\(/g, '$$')
                    .replace(/\\\)/g, '$$');
            }

            function protectMath(text) {
                const math = [];
                let i = 0;
                // 1. Protect display math $$...$$
                text = text.replace(/\$\$([\s\S]+?)\$\$/g, (match) => {
                    math.push(match);
                    return `@@MATH${i++}@@`;
                });
                // 2. Protect inline math $...$
                // Improved regex to handle escaped \$ and ensure we don't match across lines for inline
                text = text.replace(/(^|[^\\])\$([^\s$][^$\n]*?[^\s$])\$/g, (match, prefix, content) => {
                    math.push(`$${content}$`);
                    return `${prefix}@@MATH${i++}@@`;
                });
                // Special case for single character math like $x$
                text = text.replace(/(^|[^\\])\$([^\s$])\$/g, (match, prefix, content) => {
                    math.push(`$${content}$`);
                    return `${prefix}@@MATH${i++}@@`;
                });
                return { text, math };
            }

            function restoreMath(html, math) {
                return html.replace(/@@MATH(\d+)@@/g, (_, i) => math[i]);
            }

            function renderElement(targetId) {
                const targetEl = document.getElementById(targetId);
                if (!targetEl) return;

                const raw = targetEl.getAttribute('data-raw');
                if (raw && raw.trim().length > 0) {
                    try {
                        if (window.marked && window.marked.parse) {
                            const normalized = normalizeMathDelimiters(raw);
                            const { text, math } = protectMath(normalized);
                            let html = marked.parse(text);
                            html = restoreMath(html, math);
                            targetEl.innerHTML = html;
                        } else {
                            targetEl.innerHTML = '<pre style="white-space: pre-wrap">' + raw + '</pre>';
                        }
                    } catch (err) {
                        console.error('Error rendering element ' + targetId + ':', err);
                        targetEl.innerHTML = raw;
                    }
                }
            }

            function typeset(element) {
                if (window.MathJax?.typesetPromise) {
                    const promise = element ? window.MathJax.typesetPromise([element]) : window.MathJax.typesetPromise();
                    promise.catch((err) => console.error('MathJax typeset failed:', err));
                } else if (window.typesetMath) {
                    window.typesetMath();
                }
            }

            window.renderProblemSolution = function() {
                renderElement('problem-solution');
                const el = document.getElementById('problem-solution');
                if (el) typeset(el);
            };

            function init() {
                console.log('Initializing problem detail rendering...');
                renderElement('problem-statement');
                const el = document.getElementById('problem-statement');
                if (el) typeset(el);
            }

            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init();
            }

            // Retry rendering and typeset a few times in case scripts load late
            let left = 20;
            const id = setInterval(() => {
                left -= 1;
                const statementEl = document.getElementById('problem-statement');
                const isStillLoading = statementEl && statementEl.innerHTML.includes('Loading statement...');
                
                if (window.marked && window.marked.parse && isStillLoading) {
                    console.log('marked.js loaded late, rendering now...');
                    renderElement('problem-statement');
                }

                if (window.MathJax?.typesetPromise) {
                    typeset();
                    if (!isStillLoading) clearInterval(id);
                }
                
                if (left <= 0) {
                    clearInterval(id);
                }
            }, 500);
        })();
    </script>
</div>
</body>
</html>
